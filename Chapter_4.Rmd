---
title: "Chapter 4"
author: "Zexuan Zhao"
date: "15 October 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(sf)
library(raster)
library(tidyverse)
library(spData)
```

# 4.1 Introduction  

Spatial operations differ from non-spatial operations in some ways, however. To illustrate the point, imagine you are researching road safety. Spatial joins can be used to find road speed limits related with administrative zones, even when no zone ID is provided. But this raises the question: should the road completely fall inside a zone for its values to be joined? Or is simply crossing or being within a certain distance sufficent? When posing such questions it becomes apparent that spatial operations differ substantially from attribute operations on data frames: the type of spatial relationship between objects must be considered. 

# 4.2 Spatial operations on vector data  

## 4.2.1 Spatial subsetting

Spatial subsetting is the process of selecting features of a spatial object based on whether or not they in some way relate in space to another object.

Like attribute subsetting x[y, ] subsets features of a target x using the contents of a source object y. Instead of y being of class logical or integer — a vector of TRUE and FALSE values or whole numbers — for spatial subsetting it is another spatial (sf) object.  

The following code chunk first creates an object representing Canterbury, then uses spatial subsetting to return all high points in the region:  
```{r}
canterbury <-  nz %>% 
  filter(Name == "Canterbury")
canterbury_height <-  nz_height[canterbury, ] # use sf object to subset
nz %>% 
  st_geometry() %>% 
  ggplot() +
    geom_sf() +
    geom_sf(aes(col = "red"), data =canterbury_height) +
    theme(legend.position="none")
```

Various topological relations can be used for spatial subsetting. These determine the type of spatial relationship that features in the target object must have with the subsetting object to be selected, including touches, crosses or within (see section 4.2.2). Intersects is the default spatial subsetting operator, a default that returns TRUE for many types of spatial relations, including touches, crosses and is within. These alternative spatial operators can be specified with the op = argument, a third argument that can be passed to the [ operator for sf objects. 

The second argument specifies which attribute to show in the result, by default, all.

```{r}
nz_height[canterbury, , op = st_disjoint] # do the opposite as intersect
```

Using topological operators:  

```{r}
sel_sgbp <-  st_intersects(x = nz_height, y = canterbury)
# summary(sel_sgbp)
class(sel_sgbp)
sel_logical <-  lengths(sel_sgbp) > 0 # convert sgbp to logical: The function lengths() identifies which features in nz_height intersect with ANY objects in y
canterbury_height2 <-  nz_height[sel_logical, ]
```

In the above code chunk an object of class sgbp (a sparse geometry binary predicate, a list of length x in the spatial operation) is created and then converted into a logical vector sel_logical (containing only TRUE and FALSE values). The function lengths() identifies which features in nz_height intersect with any objects in y. In this case 1 is the greatest possible value but for more complex operations one could use the method to subset only features that intersect with, for example, 2 or more features from the source object.

Another way to do this is to set sparse = FALSE: 
```{r}
st_intersects(x = nz_height, y = canterbury, sparse = FALSE)
```  
The result is the same as sel_logical as there is only one row in canterbury.

A more tidy way to do this is to use dplyr function filter():  
```{r}
canterbury_height3 <- nz_height %>% 
  st_intersects(canterbury, sparse = FALSE)[,1] %>%
  filter()
```
4.2.2 Topological relations

First we need to create demonstrative sf objects:  
```{r}
# create a polygon
a_poly <-  st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a <-  st_sfc(a_poly)
# create a line
l_line <-  st_linestring(x = matrix(c(-1, -1, -0.5, 1), ncol = 2))
l <-  st_sfc(l_line)
# create points
p_matrix <-  matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2)
p_multi <-  st_multipoint(x = p_matrix)
p <-  st_cast(st_sfc(p_multi), "POINT")
ggplot() +
  geom_sf(data = a) +
  geom_sf(data = l) +
  geom_sf(data = p)
```

Using st_intersects() to find geometries in argument 1 that intersect with geometries in argument 2:  

```{r}
st_intersects(p, a)
st_intersects(p, a, sparse = FALSE)
```

Note that st_intersects() returns TRUE for the second feature in the object p even though it just touches the polygon a: intersects is a ‘catch-all’ topological operation which identifies many types of spatial relation.

Using st_disjoint() to find geometries in argument 1 that do not intersect with geometries in argument 2:  

```{r}
st_disjoint(p, a, sparse = FALSE)[, 1]
```
Using st_within() to find geometries in argument 1 that are totally within geometries in argument 2:  

```{r}
st_within(p, a, sparse = FALSE)[, 1]
```
Using st_touches() to find geometries in argument 1 that touch the boundaries of geometries in argument 2:  

```{r}
st_touches(p, a, sparse = FALSE)[, 1]
```

Using st_is_within_distance() to find geometries in argument 1 that are within a specific distance from geometries in argument 2:  

```{r}
sel = st_is_within_distance(p, a, dist = 0.9) # can only return a sparse matrix
lengths(sel) > 0
```

## 4.2.3 Spatial joining

Spatial data joining relies on shared areas of geographic space (known as spatial overlay).  

Imagine you have 10 points randomly distributed across the Earth’s surface. Of the points that are on land, which countries are they in? Random points to demonstrate spatial joining are created as follows:  

```{r}
set.seed(2018) # set seed for reproducibility
bb_world <-  st_bbox(world) # the world's bounds
random_df <-  tibble(
  x = runif(n = 10, min = bb_world[1], max = bb_world[3]),
  y = runif(n = 10, min = bb_world[2], max = bb_world[4])
)
random_points <-  random_df %>% 
  st_as_sf(coords = c("x", "y")) %>% # set coordinates
  st_set_crs(4326) # set geographic CRS
```

Using st_join() to add variables to points:  

```{r}
random_points_geo <- random_points %>% 
  st_join(world) %>% 
  select(country = name_long)
ggplot() +
  geom_sf(data = st_geometry(world)) + 
  geom_sf(data = random_points_geo)
```

## 4.2.4 Non-overlapping joins

The datasets cycle_hire and cycle_hire_osm are closely related but they do not touch.  

```{r}
plot(st_geometry(cycle_hire), col = "blue")
plot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = "red")
# We can check if any points are the same as shown below:
any(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))
```

Non-overlapping join is to assign values to related but not overlapped geometries.  
Using the topological operator st_is_within_distance() and setting a threshold distance:  

```{r}
cycle_hire_P <-  st_transform(cycle_hire, 27700)
cycle_hire_osm_P <-  st_transform(cycle_hire_osm, 27700)
sel <-  cycle_hire_P %>% 
  st_is_within_distance(cycle_hire_osm_P, dist = 20)
summary(lengths(sel) > 0)
```

This shows that there are 438 points in the target object cycle_hire_P within the threshold distance of cycle_hire_osm_P. 

Using st_join() and argument dist to do non-overlapping join:  

```{r}
z <-  cycle_hire_P %>% 
  st_join( cycle_hire_osm_P, st_is_within_distance, dist = 20)
nrow(cycle_hire)
nrow(z)
```

Note that the number of rows in the joined result is greater than the target. This is because some cycle hire stations in cycle_hire_P have multiple matches in cycle_hire_osm_P. We need toaggregate the values for the overlapping points and return the mean.  

```{r}
z <-  z %>% 
  group_by(id) %>% 
  summarize(capacity = mean(capacity))
nrow(z) == nrow(cycle_hire)
```

The capacity of nearby stations can be verified by comparing a plot of the capacity of the source cycle_hire_osm data with the results in this new object:  

```{r}
plot(cycle_hire_osm["capacity"])
plot(z["capacity"])
```

## 4.2.5 Spatial data aggregation